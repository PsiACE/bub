{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Bub Docs \u00b6 Bub is built for day-to-day coding tasks: run commands, edit files, debug failures, and keep progress visible across long sessions. What You Can Expect \u00b6 Clear command behavior: only lines that start with , are commands. One execution path: the same rules apply to both your input and assistant-generated commands. Graceful recovery: failed commands are fed back to the model with structured context. Trackable sessions: tape, anchors, and handoff help you resume work cleanly. How Bub Behaves In Practice \u00b6 Type normal text to ask the assistant. Start a line with , to run a command. Known names such as ,help are internal commands. Other comma-prefixed lines are treated as shell commands. If a command fails, Bub keeps going and uses the error context in the next model step. Start Here \u00b6 Key Features Interactive CLI Architecture Telegram Integration Common Commands \u00b6 ,help ,tools ,tool.describe name=fs.read ,tape.info ,tape.search query=timeout ,handoff name=phase-2 summary=\"router fixed\" next_steps=\"run pytest\" ,anchors ,tape.reset archive=true Configuration \u00b6 Start from env.example in the repository root. Use model + API key first, then add Telegram and advanced settings when needed.","title":"Home"},{"location":"#bub-docs","text":"Bub is built for day-to-day coding tasks: run commands, edit files, debug failures, and keep progress visible across long sessions.","title":"Bub Docs"},{"location":"#what-you-can-expect","text":"Clear command behavior: only lines that start with , are commands. One execution path: the same rules apply to both your input and assistant-generated commands. Graceful recovery: failed commands are fed back to the model with structured context. Trackable sessions: tape, anchors, and handoff help you resume work cleanly.","title":"What You Can Expect"},{"location":"#how-bub-behaves-in-practice","text":"Type normal text to ask the assistant. Start a line with , to run a command. Known names such as ,help are internal commands. Other comma-prefixed lines are treated as shell commands. If a command fails, Bub keeps going and uses the error context in the next model step.","title":"How Bub Behaves In Practice"},{"location":"#start-here","text":"Key Features Interactive CLI Architecture Telegram Integration","title":"Start Here"},{"location":"#common-commands","text":",help ,tools ,tool.describe name=fs.read ,tape.info ,tape.search query=timeout ,handoff name=phase-2 summary=\"router fixed\" next_steps=\"run pytest\" ,anchors ,tape.reset archive=true","title":"Common Commands"},{"location":"#configuration","text":"Start from env.example in the repository root. Use model + API key first, then add Telegram and advanced settings when needed.","title":"Configuration"},{"location":"architecture/","text":"Architecture \u00b6 This page is for developers and advanced users who need to understand why Bub behavior is deterministic and how to extend it safely. Core Principles \u00b6 One session, one append-only tape. Same routing rules for user input and assistant output. Command execution and model reasoning are explicit layers. Phase transitions are represented by anchor/handoff , not hidden state jumps. Runtime Topology \u00b6 input -> InputRouter -> AgentLoop -> ModelRunner -> InputRouter(assistant output) -> ... \\-> direct command response Key modules: src/bub/core/router.py : command detection, execution, and failure context wrapping. src/bub/core/agent_loop.py : turn orchestration and stop conditions. src/bub/core/model_runner.py : bounded model loop and user-driven skill-hint activation. src/bub/tape/service.py : tape read/write, anchor/handoff, reset, and search. src/bub/tools/* : unified registry and progressive tool view. Single Turn Flow \u00b6 InputRouter.route_user checks whether input starts with , . If command succeeds, return output directly. If command fails, generate a <command ...> block for model context. ModelRunner gets assistant output. route_assistant applies the same command parsing/execution rules. Loop ends on plain final text, explicit quit, or max_steps . Tape, Anchor, Handoff \u00b6 Tape is workspace-level JSONL for replay and audit. handoff writes an anchor with optional summary and next_steps . anchors lists phase boundaries. tape.reset clears active context (optionally archiving first). Tools and Skills \u00b6 Built-in tools and skills live in one registry. System prompt starts with compact tool descriptions. Full tool schema is expanded on demand ( tool.describe or explicit selection). $name hints progressively expand tool/skill details from either user input or model output.","title":"Architecture"},{"location":"architecture/#architecture","text":"This page is for developers and advanced users who need to understand why Bub behavior is deterministic and how to extend it safely.","title":"Architecture"},{"location":"architecture/#core-principles","text":"One session, one append-only tape. Same routing rules for user input and assistant output. Command execution and model reasoning are explicit layers. Phase transitions are represented by anchor/handoff , not hidden state jumps.","title":"Core Principles"},{"location":"architecture/#runtime-topology","text":"input -> InputRouter -> AgentLoop -> ModelRunner -> InputRouter(assistant output) -> ... \\-> direct command response Key modules: src/bub/core/router.py : command detection, execution, and failure context wrapping. src/bub/core/agent_loop.py : turn orchestration and stop conditions. src/bub/core/model_runner.py : bounded model loop and user-driven skill-hint activation. src/bub/tape/service.py : tape read/write, anchor/handoff, reset, and search. src/bub/tools/* : unified registry and progressive tool view.","title":"Runtime Topology"},{"location":"architecture/#single-turn-flow","text":"InputRouter.route_user checks whether input starts with , . If command succeeds, return output directly. If command fails, generate a <command ...> block for model context. ModelRunner gets assistant output. route_assistant applies the same command parsing/execution rules. Loop ends on plain final text, explicit quit, or max_steps .","title":"Single Turn Flow"},{"location":"architecture/#tape-anchor-handoff","text":"Tape is workspace-level JSONL for replay and audit. handoff writes an anchor with optional summary and next_steps . anchors lists phase boundaries. tape.reset clears active context (optionally archiving first).","title":"Tape, Anchor, Handoff"},{"location":"architecture/#tools-and-skills","text":"Built-in tools and skills live in one registry. System prompt starts with compact tool descriptions. Full tool schema is expanded on demand ( tool.describe or explicit selection). $name hints progressively expand tool/skill details from either user input or model output.","title":"Tools and Skills"},{"location":"cli/","text":"Interactive CLI \u00b6 Start \u00b6 uv run bub Optional: uv run bub chat --workspace /path/to/repo --model openrouter:qwen/qwen3-coder-next --max-tokens 1400 How Input Is Interpreted \u00b6 Only lines starting with , are interpreted as commands. Registered names like ,help are internal commands. Other comma-prefixed lines run through shell, for example ,git status . Non-comma input is always treated as natural language. This rule is shared by both user input and assistant output. Shell Mode \u00b6 Press Ctrl-X to toggle between agent and shell mode. agent mode: send input as typed. shell mode: if input does not start with , , Bub auto-normalizes it to , <your command> . Use shell mode when you want to run multiple shell commands quickly. Typical Workflow \u00b6 Check repo status: ,git status Read files: ,fs.read path=README.md Edit files: ,fs.edit path=foo.py old=... new=... Validate: ,uv run pytest -q Mark phase transition: ,handoff name=phase-x summary=\"tests pass\" Session Context Commands \u00b6 ,tape.info ,tape.search query=error ,anchors ,tape.reset archive=true ,tape.reset archive=true archives then clears current tape. ,anchors shows phase boundaries. Troubleshooting \u00b6 command not found : verify whether it should be an internal command ( ,help for list). Verbose or odd output: Bub may still be processing command follow-up context. Context is too heavy: add a handoff anchor, then reset tape when needed.","title":"Interactive CLI"},{"location":"cli/#interactive-cli","text":"","title":"Interactive CLI"},{"location":"cli/#start","text":"uv run bub Optional: uv run bub chat --workspace /path/to/repo --model openrouter:qwen/qwen3-coder-next --max-tokens 1400","title":"Start"},{"location":"cli/#how-input-is-interpreted","text":"Only lines starting with , are interpreted as commands. Registered names like ,help are internal commands. Other comma-prefixed lines run through shell, for example ,git status . Non-comma input is always treated as natural language. This rule is shared by both user input and assistant output.","title":"How Input Is Interpreted"},{"location":"cli/#shell-mode","text":"Press Ctrl-X to toggle between agent and shell mode. agent mode: send input as typed. shell mode: if input does not start with , , Bub auto-normalizes it to , <your command> . Use shell mode when you want to run multiple shell commands quickly.","title":"Shell Mode"},{"location":"cli/#typical-workflow","text":"Check repo status: ,git status Read files: ,fs.read path=README.md Edit files: ,fs.edit path=foo.py old=... new=... Validate: ,uv run pytest -q Mark phase transition: ,handoff name=phase-x summary=\"tests pass\"","title":"Typical Workflow"},{"location":"cli/#session-context-commands","text":",tape.info ,tape.search query=error ,anchors ,tape.reset archive=true ,tape.reset archive=true archives then clears current tape. ,anchors shows phase boundaries.","title":"Session Context Commands"},{"location":"cli/#troubleshooting","text":"command not found : verify whether it should be an internal command ( ,help for list). Verbose or odd output: Bub may still be processing command follow-up context. Context is too heavy: add a handoff anchor, then reset tape when needed.","title":"Troubleshooting"},{"location":"features/","text":"Key Features \u00b6 This page summarizes the capabilities users rely on most when working with Bub. 1. Deterministic Command Routing \u00b6 Command mode is explicit: only line-start , triggers command parsing. Known names map to internal commands (for example ,help , ,tools , ,tape.info ). Other comma-prefixed lines run as shell commands (for example ,git status ). Why it matters: fewer accidental tool calls and more predictable behavior. 2. Command Failure Recovery \u00b6 Successful commands return directly. Failed commands are wrapped as structured command blocks and sent back to the model loop. Why it matters: the assistant can debug based on real command output instead of generic guesses. 3. Tape-First Session Memory \u00b6 Bub writes session activity to append-only tape. ,anchors and ,handoff mark phase transitions. ,tape.search and ,tape.info help inspect context quickly. Why it matters: long tasks stay traceable and easier to resume. 4. Unified Tool + Skill View \u00b6 Built-in tools and skills share one registry. Prompt includes compact tool descriptions first. Tool details expand on explicit selection (for example ,tool.describe name=fs.read ). $name hints expand details progressively for both tools and skills. Hints can come from user input or model output (for example $fs.read , $friendly-python ). Why it matters: prompt stays focused while advanced capabilities remain available on demand. 5. Interactive CLI Focused on Real Work \u00b6 Rich interactive shell with history and completions. Ctrl-X toggles shell mode for faster command execution. Same runtime behavior as channel integrations. Why it matters: local debugging and implementation loops are fast and consistent. 6. Telegram Channel Integration \u00b6 Optional long-polling Telegram adapter. Per-chat session isolation ( telegram:<chat_id> ). Optional sender allowlist for access control. Why it matters: you can continue lightweight operations from mobile or remote environments.","title":"Key Features"},{"location":"features/#key-features","text":"This page summarizes the capabilities users rely on most when working with Bub.","title":"Key Features"},{"location":"features/#1-deterministic-command-routing","text":"Command mode is explicit: only line-start , triggers command parsing. Known names map to internal commands (for example ,help , ,tools , ,tape.info ). Other comma-prefixed lines run as shell commands (for example ,git status ). Why it matters: fewer accidental tool calls and more predictable behavior.","title":"1. Deterministic Command Routing"},{"location":"features/#2-command-failure-recovery","text":"Successful commands return directly. Failed commands are wrapped as structured command blocks and sent back to the model loop. Why it matters: the assistant can debug based on real command output instead of generic guesses.","title":"2. Command Failure Recovery"},{"location":"features/#3-tape-first-session-memory","text":"Bub writes session activity to append-only tape. ,anchors and ,handoff mark phase transitions. ,tape.search and ,tape.info help inspect context quickly. Why it matters: long tasks stay traceable and easier to resume.","title":"3. Tape-First Session Memory"},{"location":"features/#4-unified-tool-skill-view","text":"Built-in tools and skills share one registry. Prompt includes compact tool descriptions first. Tool details expand on explicit selection (for example ,tool.describe name=fs.read ). $name hints expand details progressively for both tools and skills. Hints can come from user input or model output (for example $fs.read , $friendly-python ). Why it matters: prompt stays focused while advanced capabilities remain available on demand.","title":"4. Unified Tool + Skill View"},{"location":"features/#5-interactive-cli-focused-on-real-work","text":"Rich interactive shell with history and completions. Ctrl-X toggles shell mode for faster command execution. Same runtime behavior as channel integrations. Why it matters: local debugging and implementation loops are fast and consistent.","title":"5. Interactive CLI Focused on Real Work"},{"location":"features/#6-telegram-channel-integration","text":"Optional long-polling Telegram adapter. Per-chat session isolation ( telegram:<chat_id> ). Optional sender allowlist for access control. Why it matters: you can continue lightweight operations from mobile or remote environments.","title":"6. Telegram Channel Integration"},{"location":"telegram/","text":"Telegram Integration \u00b6 Telegram allows Bub to run as a remote coding assistant entry point for lightweight operations. Configure \u00b6 BUB_TELEGRAM_ENABLED = true BUB_TELEGRAM_TOKEN = 123456 :token BUB_TELEGRAM_ALLOW_FROM =[ \"123456789\" , \"your_username\" ] Notes: If BUB_TELEGRAM_ALLOW_FROM is empty, all senders are accepted. In production, use a strict allowlist. Run \u00b6 uv run bub telegram Runtime Behavior \u00b6 Uses long polling. Each Telegram chat maps to telegram:<chat_id> session key. Inbound text enters the same AgentLoop used by CLI. Outbound messages are sent by ChannelManager . Typing indicator is emitted while processing. Security and Operations \u00b6 Keep bot token only in .env or a secret manager. Use a dedicated bot account. Keep allowlist updated with valid user IDs/usernames. If no response is observed, check network, token, then runtime/model logs.","title":"Telegram"},{"location":"telegram/#telegram-integration","text":"Telegram allows Bub to run as a remote coding assistant entry point for lightweight operations.","title":"Telegram Integration"},{"location":"telegram/#configure","text":"BUB_TELEGRAM_ENABLED = true BUB_TELEGRAM_TOKEN = 123456 :token BUB_TELEGRAM_ALLOW_FROM =[ \"123456789\" , \"your_username\" ] Notes: If BUB_TELEGRAM_ALLOW_FROM is empty, all senders are accepted. In production, use a strict allowlist.","title":"Configure"},{"location":"telegram/#run","text":"uv run bub telegram","title":"Run"},{"location":"telegram/#runtime-behavior","text":"Uses long polling. Each Telegram chat maps to telegram:<chat_id> session key. Inbound text enters the same AgentLoop used by CLI. Outbound messages are sent by ChannelManager . Typing indicator is emitted while processing.","title":"Runtime Behavior"},{"location":"telegram/#security-and-operations","text":"Keep bot token only in .env or a secret manager. Use a dedicated bot account. Keep allowlist updated with valid user IDs/usernames. If no response is observed, check network, token, then runtime/model logs.","title":"Security and Operations"},{"location":"posts/2025-07-16-baby-bub-bootstrap-milestone/","text":"Baby Bub: From Inspiration to Bootstrap Milestone \u00b6 Genesis: Inspiration from Modern Agents \u00b6 Bub is a CLI-first AI agent, built to \"Bub it. Build it.\" The project draws direct inspiration from How to Build an Agent and Tiny Agents: Building LLM-Powered Agents from Scratch . Both resources distill the essence of tool-using, loop-based, composable, and extensible agents. But Bub is also a response to the new wave of self-improving, self-hosting agents: think Claude Code, SWE-agent, and the broader \"self-bootstrapping\" movement. The goal: an agent that can not only help you build, but can help build (and fix) itself. Architecture: ReAct Loop, Tools, and CLI \u00b6 The ReAct Loop \u00b6 At the heart of Bub is a classic ReAct loop, implemented in src/bub/agent/core.py : class Agent : ... def chat ( self , message : str , on_step : Optional [ Callable [[ str , str ], None ]] = None ) -> str : self . conversation_history . append ( Message ( role = \"user\" , content = message )) while True : ... response = litellm . completion ( ... ) assistant_message = str ( response . choices [ 0 ] . message . content ) self . conversation_history . append ( Message ( role = \"assistant\" , content = assistant_message )) ... tool_calls = self . tool_executor . extract_tool_calls ( assistant_message ) if tool_calls : for tool_call in tool_calls : ... result = self . tool_executor . execute_tool ( tool_name , ** parameters ) observation = f \"Observation: { result . format_result () } \" self . conversation_history . append ( Message ( role = \"user\" , content = observation )) ... continue else : return assistant_message This loop enables the agent to: Parse LLM output for tool calls (ReAct pattern: Thought, Action, Action Input, Observation). Execute tools (file read/write/edit, shell commands) and feed results back into the conversation. Iterate until a \"Final Answer\" is produced. Tool System: Extensible and Safe \u00b6 Tools are registered via a ToolRegistry ( src/bub/agent/tools.py ), and each tool is a Pydantic model with validation and metadata. For example, the RunCommandTool blocks dangerous commands and validates input: class RunCommandTool ( Tool ): ... DANGEROUS_COMMANDS : ClassVar [ set [ str ]] = { \"rm\" , \"del\" , ... } def _validate_command ( self ) -> Optional [ str ]: ... if base_cmd in self . DANGEROUS_COMMANDS : return f \"Dangerous command blocked: { base_cmd } \" This design makes it possible for the agent to safely self-modify, run tests, or even edit its own codebase\u2014crucial for self-improvement. CLI: User Experience and Debuggability \u00b6 The CLI ( src/bub/cli/app.py ) is built with Typer and Rich, providing a modern, user-friendly interface. The renderer ( src/bub/cli/render.py ) supports debug toggling, minimal/verbose TAAO (Thought/Action/Action Input/Observation) output, and clear error reporting. class Renderer : def __init__ ( self ) -> None : self . console : Console = Console () self . _show_debug : bool = False ... Milestone: The First mypy Fix (and Why It Matters) \u00b6 Bub aspires to self-improvement. The first tangible milestone? Fixing the very first mypy error: adding a missing return type annotation to Renderer.__init__ , check out the commit . - def __init__(self): - self.console = Console() - self._show_debug = False + def __init__(self) -> None: + self.console: Console = Console() + self._show_debug: bool = False This change reduced the mypy error count from 24 to 23. Trivial? Maybe. But it's a proof of concept: the agent can reason about, locate, and fix type errors in its own codebase. This is the first step toward a self-hosting, self-healing agent loop\u2014one that can eventually: Run static analysis on itself Propose and apply code fixes Test and validate improvements Looking Forward: Bub as a Bootstrap Agent \u00b6 Bub is still early. But the architecture is in place for: LLM-driven code editing and refactoring Automated type and lint fixes CLI-driven, user-friendly agent workflows The journey from \"fixing a mypy annotation\" to \"full agent self-improvement\" is long, but every bootstrap starts with a single, type-safe step. Project on GitHub Inspired by ampcode.com/how-to-build-an-agent and huggingface.co/blog/tiny-agents See also: Claude Code, SWE-agent, and the broader self-bootstrapping movement","title":"Baby Bub: From Inspiration to Bootstrap Milestone"},{"location":"posts/2025-07-16-baby-bub-bootstrap-milestone/#baby-bub-from-inspiration-to-bootstrap-milestone","text":"","title":"Baby Bub: From Inspiration to Bootstrap Milestone"},{"location":"posts/2025-07-16-baby-bub-bootstrap-milestone/#genesis-inspiration-from-modern-agents","text":"Bub is a CLI-first AI agent, built to \"Bub it. Build it.\" The project draws direct inspiration from How to Build an Agent and Tiny Agents: Building LLM-Powered Agents from Scratch . Both resources distill the essence of tool-using, loop-based, composable, and extensible agents. But Bub is also a response to the new wave of self-improving, self-hosting agents: think Claude Code, SWE-agent, and the broader \"self-bootstrapping\" movement. The goal: an agent that can not only help you build, but can help build (and fix) itself.","title":"Genesis: Inspiration from Modern Agents"},{"location":"posts/2025-07-16-baby-bub-bootstrap-milestone/#architecture-react-loop-tools-and-cli","text":"","title":"Architecture: ReAct Loop, Tools, and CLI"},{"location":"posts/2025-07-16-baby-bub-bootstrap-milestone/#the-react-loop","text":"At the heart of Bub is a classic ReAct loop, implemented in src/bub/agent/core.py : class Agent : ... def chat ( self , message : str , on_step : Optional [ Callable [[ str , str ], None ]] = None ) -> str : self . conversation_history . append ( Message ( role = \"user\" , content = message )) while True : ... response = litellm . completion ( ... ) assistant_message = str ( response . choices [ 0 ] . message . content ) self . conversation_history . append ( Message ( role = \"assistant\" , content = assistant_message )) ... tool_calls = self . tool_executor . extract_tool_calls ( assistant_message ) if tool_calls : for tool_call in tool_calls : ... result = self . tool_executor . execute_tool ( tool_name , ** parameters ) observation = f \"Observation: { result . format_result () } \" self . conversation_history . append ( Message ( role = \"user\" , content = observation )) ... continue else : return assistant_message This loop enables the agent to: Parse LLM output for tool calls (ReAct pattern: Thought, Action, Action Input, Observation). Execute tools (file read/write/edit, shell commands) and feed results back into the conversation. Iterate until a \"Final Answer\" is produced.","title":"The ReAct Loop"},{"location":"posts/2025-07-16-baby-bub-bootstrap-milestone/#tool-system-extensible-and-safe","text":"Tools are registered via a ToolRegistry ( src/bub/agent/tools.py ), and each tool is a Pydantic model with validation and metadata. For example, the RunCommandTool blocks dangerous commands and validates input: class RunCommandTool ( Tool ): ... DANGEROUS_COMMANDS : ClassVar [ set [ str ]] = { \"rm\" , \"del\" , ... } def _validate_command ( self ) -> Optional [ str ]: ... if base_cmd in self . DANGEROUS_COMMANDS : return f \"Dangerous command blocked: { base_cmd } \" This design makes it possible for the agent to safely self-modify, run tests, or even edit its own codebase\u2014crucial for self-improvement.","title":"Tool System: Extensible and Safe"},{"location":"posts/2025-07-16-baby-bub-bootstrap-milestone/#cli-user-experience-and-debuggability","text":"The CLI ( src/bub/cli/app.py ) is built with Typer and Rich, providing a modern, user-friendly interface. The renderer ( src/bub/cli/render.py ) supports debug toggling, minimal/verbose TAAO (Thought/Action/Action Input/Observation) output, and clear error reporting. class Renderer : def __init__ ( self ) -> None : self . console : Console = Console () self . _show_debug : bool = False ...","title":"CLI: User Experience and Debuggability"},{"location":"posts/2025-07-16-baby-bub-bootstrap-milestone/#milestone-the-first-mypy-fix-and-why-it-matters","text":"Bub aspires to self-improvement. The first tangible milestone? Fixing the very first mypy error: adding a missing return type annotation to Renderer.__init__ , check out the commit . - def __init__(self): - self.console = Console() - self._show_debug = False + def __init__(self) -> None: + self.console: Console = Console() + self._show_debug: bool = False This change reduced the mypy error count from 24 to 23. Trivial? Maybe. But it's a proof of concept: the agent can reason about, locate, and fix type errors in its own codebase. This is the first step toward a self-hosting, self-healing agent loop\u2014one that can eventually: Run static analysis on itself Propose and apply code fixes Test and validate improvements","title":"Milestone: The First mypy Fix (and Why It Matters)"},{"location":"posts/2025-07-16-baby-bub-bootstrap-milestone/#looking-forward-bub-as-a-bootstrap-agent","text":"Bub is still early. But the architecture is in place for: LLM-driven code editing and refactoring Automated type and lint fixes CLI-driven, user-friendly agent workflows The journey from \"fixing a mypy annotation\" to \"full agent self-improvement\" is long, but every bootstrap starts with a single, type-safe step. Project on GitHub Inspired by ampcode.com/how-to-build-an-agent and huggingface.co/blog/tiny-agents See also: Claude Code, SWE-agent, and the broader self-bootstrapping movement","title":"Looking Forward: Bub as a Bootstrap Agent"}]}