{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Bub Docs \u00b6 Bub is built for day-to-day coding tasks: run commands, edit files, debug failures, and keep progress visible across long sessions. What You Can Expect \u00b6 Clear command behavior: only lines that start with , are commands. One execution path: the same rules apply to both your input and assistant-generated commands. Graceful recovery: failed commands are fed back to the model with structured context. Trackable sessions: tape, anchors, and handoff help you resume work cleanly. How Bub Behaves In Practice \u00b6 Type normal text to ask the assistant. Start a line with , to run a command. Known names such as ,help are internal commands. Other comma-prefixed lines are treated as shell commands. If a command fails, Bub keeps going and uses the error context in the next model step. Start Here \u00b6 Key Features Interactive CLI Deployment Guide Architecture Telegram Integration Discord Integration Common Commands \u00b6 ,help ,tools ,tool.describe name=fs.read ,tape.info ,tape.search query=timeout ,handoff name=phase-2 summary=\"router fixed\" next_steps=\"run pytest\" ,anchors ,tape.reset archive=true Configuration \u00b6 Start from env.example in the repository root. Use model + API key first, then add Telegram and advanced settings when needed.","title":"Home"},{"location":"#bub-docs","text":"Bub is built for day-to-day coding tasks: run commands, edit files, debug failures, and keep progress visible across long sessions.","title":"Bub Docs"},{"location":"#what-you-can-expect","text":"Clear command behavior: only lines that start with , are commands. One execution path: the same rules apply to both your input and assistant-generated commands. Graceful recovery: failed commands are fed back to the model with structured context. Trackable sessions: tape, anchors, and handoff help you resume work cleanly.","title":"What You Can Expect"},{"location":"#how-bub-behaves-in-practice","text":"Type normal text to ask the assistant. Start a line with , to run a command. Known names such as ,help are internal commands. Other comma-prefixed lines are treated as shell commands. If a command fails, Bub keeps going and uses the error context in the next model step.","title":"How Bub Behaves In Practice"},{"location":"#start-here","text":"Key Features Interactive CLI Deployment Guide Architecture Telegram Integration Discord Integration","title":"Start Here"},{"location":"#common-commands","text":",help ,tools ,tool.describe name=fs.read ,tape.info ,tape.search query=timeout ,handoff name=phase-2 summary=\"router fixed\" next_steps=\"run pytest\" ,anchors ,tape.reset archive=true","title":"Common Commands"},{"location":"#configuration","text":"Start from env.example in the repository root. Use model + API key first, then add Telegram and advanced settings when needed.","title":"Configuration"},{"location":"architecture/","text":"Architecture \u00b6 This page is for developers and advanced users who need to understand why Bub behavior is deterministic and how to extend it safely. Core Principles \u00b6 One session, one append-only tape. Same routing rules for user input and assistant output. Command execution and model reasoning are explicit layers. Phase transitions are represented by anchor/handoff , not hidden state jumps. Runtime Topology \u00b6 input -> InputRouter -> AgentLoop -> ModelRunner -> InputRouter(assistant output) -> ... \\-> direct command response Key modules: src/bub/core/router.py : command detection, execution, and failure context wrapping. src/bub/core/agent_loop.py : turn orchestration and stop conditions. src/bub/core/model_runner.py : bounded model loop and user-driven skill-hint activation. src/bub/tape/service.py : tape read/write, anchor/handoff, reset, and search. src/bub/tools/* : unified registry and progressive tool view. Single Turn Flow \u00b6 InputRouter.route_user checks whether input starts with , . If command succeeds, return output directly. If command fails, generate a <command ...> block for model context. ModelRunner gets assistant output. route_assistant applies the same command parsing/execution rules. Loop ends on plain final text, explicit quit, or max_steps . Tape, Anchor, Handoff \u00b6 Tape is workspace-level JSONL for replay and audit. handoff writes an anchor with optional summary and next_steps . anchors lists phase boundaries. tape.reset clears active context (optionally archiving first). Tools and Skills \u00b6 Built-in tools and skills live in one registry. System prompt starts with compact tool descriptions. Full tool schema is expanded on demand ( tool.describe or explicit selection). $name hints progressively expand tool/skill details from either user input or model output.","title":"Architecture"},{"location":"architecture/#architecture","text":"This page is for developers and advanced users who need to understand why Bub behavior is deterministic and how to extend it safely.","title":"Architecture"},{"location":"architecture/#core-principles","text":"One session, one append-only tape. Same routing rules for user input and assistant output. Command execution and model reasoning are explicit layers. Phase transitions are represented by anchor/handoff , not hidden state jumps.","title":"Core Principles"},{"location":"architecture/#runtime-topology","text":"input -> InputRouter -> AgentLoop -> ModelRunner -> InputRouter(assistant output) -> ... \\-> direct command response Key modules: src/bub/core/router.py : command detection, execution, and failure context wrapping. src/bub/core/agent_loop.py : turn orchestration and stop conditions. src/bub/core/model_runner.py : bounded model loop and user-driven skill-hint activation. src/bub/tape/service.py : tape read/write, anchor/handoff, reset, and search. src/bub/tools/* : unified registry and progressive tool view.","title":"Runtime Topology"},{"location":"architecture/#single-turn-flow","text":"InputRouter.route_user checks whether input starts with , . If command succeeds, return output directly. If command fails, generate a <command ...> block for model context. ModelRunner gets assistant output. route_assistant applies the same command parsing/execution rules. Loop ends on plain final text, explicit quit, or max_steps .","title":"Single Turn Flow"},{"location":"architecture/#tape-anchor-handoff","text":"Tape is workspace-level JSONL for replay and audit. handoff writes an anchor with optional summary and next_steps . anchors lists phase boundaries. tape.reset clears active context (optionally archiving first).","title":"Tape, Anchor, Handoff"},{"location":"architecture/#tools-and-skills","text":"Built-in tools and skills live in one registry. System prompt starts with compact tool descriptions. Full tool schema is expanded on demand ( tool.describe or explicit selection). $name hints progressively expand tool/skill details from either user input or model output.","title":"Tools and Skills"},{"location":"cli/","text":"Interactive CLI \u00b6 Runtime Commands \u00b6 uv run bub chat Optional chat flags: uv run bub chat \\ --workspace /path/to/repo \\ --model openrouter:qwen/qwen3-coder-next \\ --max-tokens 1400 \\ --session-id cli-main Other runtime modes: uv run bub run \"summarize current repo status\" : one-shot message and exit. uv run bub message : run enabled message channels (Telegram/Discord). uv run bub idle : run scheduler only (no interactive CLI). How Input Is Interpreted \u00b6 Only lines starting with , are interpreted as commands. Registered names like ,help are internal commands. Other comma-prefixed lines run through shell, for example ,git status . Non-comma input is always treated as natural language. This rule is shared by both user input and assistant output. Shell Mode \u00b6 Press Ctrl-X to toggle between agent and shell mode. agent mode: send input as typed. shell mode: if input does not start with , , Bub auto-normalizes it to , <your command> . Use shell mode when you want to run multiple shell commands quickly. Typical Workflow \u00b6 Check repo status: ,git status Read files: ,fs.read path=README.md Edit files: ,fs.edit path=foo.py old=... new=... Validate: uv run pytest -q Mark phase transition: ,handoff name=phase-x summary=\"tests pass\" Session Context Commands \u00b6 ,tape.info ,tape.search query=error ,anchors ,tape.reset archive=true ,tape.reset archive=true archives then clears current tape. ,anchors shows phase boundaries. One-Shot Examples \u00b6 uv run bub run \",help\" uv run bub run --tools fs.read,fs.glob --skills friendly-python \"inspect Python layout\" uv run bub run --disable-scheduler \"quick reasoning task\" Troubleshooting \u00b6 command not found : verify whether it should be an internal command ( ,help for list). bub message exits immediately: no message channel is enabled in .env . Context is too heavy: add a handoff anchor, then reset tape when needed.","title":"Interactive CLI"},{"location":"cli/#interactive-cli","text":"","title":"Interactive CLI"},{"location":"cli/#runtime-commands","text":"uv run bub chat Optional chat flags: uv run bub chat \\ --workspace /path/to/repo \\ --model openrouter:qwen/qwen3-coder-next \\ --max-tokens 1400 \\ --session-id cli-main Other runtime modes: uv run bub run \"summarize current repo status\" : one-shot message and exit. uv run bub message : run enabled message channels (Telegram/Discord). uv run bub idle : run scheduler only (no interactive CLI).","title":"Runtime Commands"},{"location":"cli/#how-input-is-interpreted","text":"Only lines starting with , are interpreted as commands. Registered names like ,help are internal commands. Other comma-prefixed lines run through shell, for example ,git status . Non-comma input is always treated as natural language. This rule is shared by both user input and assistant output.","title":"How Input Is Interpreted"},{"location":"cli/#shell-mode","text":"Press Ctrl-X to toggle between agent and shell mode. agent mode: send input as typed. shell mode: if input does not start with , , Bub auto-normalizes it to , <your command> . Use shell mode when you want to run multiple shell commands quickly.","title":"Shell Mode"},{"location":"cli/#typical-workflow","text":"Check repo status: ,git status Read files: ,fs.read path=README.md Edit files: ,fs.edit path=foo.py old=... new=... Validate: uv run pytest -q Mark phase transition: ,handoff name=phase-x summary=\"tests pass\"","title":"Typical Workflow"},{"location":"cli/#session-context-commands","text":",tape.info ,tape.search query=error ,anchors ,tape.reset archive=true ,tape.reset archive=true archives then clears current tape. ,anchors shows phase boundaries.","title":"Session Context Commands"},{"location":"cli/#one-shot-examples","text":"uv run bub run \",help\" uv run bub run --tools fs.read,fs.glob --skills friendly-python \"inspect Python layout\" uv run bub run --disable-scheduler \"quick reasoning task\"","title":"One-Shot Examples"},{"location":"cli/#troubleshooting","text":"command not found : verify whether it should be an internal command ( ,help for list). bub message exits immediately: no message channel is enabled in .env . Context is too heavy: add a handoff anchor, then reset tape when needed.","title":"Troubleshooting"},{"location":"deployment/","text":"Deployment Guide \u00b6 This page covers production-oriented setups for Bub, including local process management and Docker Compose. 1) Prerequisites \u00b6 Python 3.12+ uv installed A valid model provider key (for example OPENROUTER_API_KEY or LLM_API_KEY ) Quick bootstrap: git clone https://github.com/psiace/bub.git cd bub uv sync cp env.example .env Minimum .env : BUB_MODEL = openrouter:qwen/qwen3-coder-next OPENROUTER_API_KEY = sk-or-... 2) Deployment Modes \u00b6 Choose one mode based on your operation target: Interactive local operator: uv run bub chat Channel service (Telegram/Discord): uv run bub message Scheduler-only autonomous runtime: uv run bub idle One-shot operation: uv run bub run \"summarize changes in this repo\" 3) Message Channel Deployment \u00b6 Enable channels in .env first. Telegram: BUB_TELEGRAM_ENABLED = true BUB_TELEGRAM_TOKEN = 123456 :token BUB_TELEGRAM_ALLOW_FROM = '[\"123456789\",\"your_username\"]' BUB_TELEGRAM_ALLOW_CHATS = '[\"123456789\",\"-1001234567890\"]' Discord: BUB_DISCORD_ENABLED = true BUB_DISCORD_TOKEN = discord_bot_token BUB_DISCORD_ALLOW_FROM = '[\"123456789012345678\",\"your_discord_name\"]' BUB_DISCORD_ALLOW_CHANNELS = '[\"123456789012345678\"]' Start channel service: uv run bub message 4) Docker Compose Deployment \u00b6 The repository already provides Dockerfile , docker-compose.yml , and entrypoint.sh . Build and run: docker compose up -d --build docker compose logs -f app Behavior in container: If /workspace/startup.sh exists, container starts bub idle in background, then executes startup.sh . Otherwise, container starts bub message . Default mounts in docker-compose.yml : ${BUB_WORKSPACE_PATH:-.}:/workspace ${BUB_HOME:-${HOME}/.bub}:/data ${BUB_AGENT_HOME:-${HOME}/.agent}:/root/.agent 5) Operational Checks \u00b6 Health checklist: Process is running: ps aux | rg \"bub (chat|message|idle)\" Model key is loaded: rg -n \"BUB_MODEL|OPENROUTER_API_KEY|LLM_API_KEY\" .env Channel flags are correct: rg -n \"BUB_TELEGRAM_ENABLED|BUB_DISCORD_ENABLED\" .env Logs show channel startup: uv run bub message and confirm channel.manager.start output. 6) Safe Upgrade Procedure \u00b6 git fetch --all --tags git pull uv sync uv run ruff check . uv run mypy uv run pytest -q Then restart your runtime ( chat , message , or container service).","title":"Deployment"},{"location":"deployment/#deployment-guide","text":"This page covers production-oriented setups for Bub, including local process management and Docker Compose.","title":"Deployment Guide"},{"location":"deployment/#1-prerequisites","text":"Python 3.12+ uv installed A valid model provider key (for example OPENROUTER_API_KEY or LLM_API_KEY ) Quick bootstrap: git clone https://github.com/psiace/bub.git cd bub uv sync cp env.example .env Minimum .env : BUB_MODEL = openrouter:qwen/qwen3-coder-next OPENROUTER_API_KEY = sk-or-...","title":"1) Prerequisites"},{"location":"deployment/#2-deployment-modes","text":"Choose one mode based on your operation target: Interactive local operator: uv run bub chat Channel service (Telegram/Discord): uv run bub message Scheduler-only autonomous runtime: uv run bub idle One-shot operation: uv run bub run \"summarize changes in this repo\"","title":"2) Deployment Modes"},{"location":"deployment/#3-message-channel-deployment","text":"Enable channels in .env first. Telegram: BUB_TELEGRAM_ENABLED = true BUB_TELEGRAM_TOKEN = 123456 :token BUB_TELEGRAM_ALLOW_FROM = '[\"123456789\",\"your_username\"]' BUB_TELEGRAM_ALLOW_CHATS = '[\"123456789\",\"-1001234567890\"]' Discord: BUB_DISCORD_ENABLED = true BUB_DISCORD_TOKEN = discord_bot_token BUB_DISCORD_ALLOW_FROM = '[\"123456789012345678\",\"your_discord_name\"]' BUB_DISCORD_ALLOW_CHANNELS = '[\"123456789012345678\"]' Start channel service: uv run bub message","title":"3) Message Channel Deployment"},{"location":"deployment/#4-docker-compose-deployment","text":"The repository already provides Dockerfile , docker-compose.yml , and entrypoint.sh . Build and run: docker compose up -d --build docker compose logs -f app Behavior in container: If /workspace/startup.sh exists, container starts bub idle in background, then executes startup.sh . Otherwise, container starts bub message . Default mounts in docker-compose.yml : ${BUB_WORKSPACE_PATH:-.}:/workspace ${BUB_HOME:-${HOME}/.bub}:/data ${BUB_AGENT_HOME:-${HOME}/.agent}:/root/.agent","title":"4) Docker Compose Deployment"},{"location":"deployment/#5-operational-checks","text":"Health checklist: Process is running: ps aux | rg \"bub (chat|message|idle)\" Model key is loaded: rg -n \"BUB_MODEL|OPENROUTER_API_KEY|LLM_API_KEY\" .env Channel flags are correct: rg -n \"BUB_TELEGRAM_ENABLED|BUB_DISCORD_ENABLED\" .env Logs show channel startup: uv run bub message and confirm channel.manager.start output.","title":"5) Operational Checks"},{"location":"deployment/#6-safe-upgrade-procedure","text":"git fetch --all --tags git pull uv sync uv run ruff check . uv run mypy uv run pytest -q Then restart your runtime ( chat , message , or container service).","title":"6) Safe Upgrade Procedure"},{"location":"discord/","text":"Discord Integration \u00b6 Discord allows Bub to run as a remote coding assistant for team channels, threads, and DMs. Configure \u00b6 BUB_DISCORD_ENABLED = true BUB_DISCORD_TOKEN = discord_bot_token BUB_DISCORD_ALLOW_FROM = '[\"123456789012345678\",\"your_discord_name\"]' BUB_DISCORD_ALLOW_CHANNELS = '[\"123456789012345678\"]' Optional: BUB_DISCORD_COMMAND_PREFIX = ! BUB_DISCORD_PROXY = http://127.0.0.1:7890 Notes: If BUB_DISCORD_ALLOW_FROM is empty, all senders are accepted. If BUB_DISCORD_ALLOW_CHANNELS is empty, all channels are accepted. In production, use strict allowlists. Run \u00b6 uv run bub message Runtime Behavior \u00b6 Uses discord.py bot runtime. Each Discord channel maps to discord:<channel_id> session key. Inbound text enters the same AgentLoop used by CLI. Outbound immediate output is sent back in-channel (split into chunks when too long). Bub processes messages in these cases: DM channel message includes bub message starts with !bub (or your configured prefix) message mentions the bot message replies to a bot message thread name starts with bub Security and Operations \u00b6 Keep bot token only in .env or a secret manager. Restrict BUB_DISCORD_ALLOW_CHANNELS and BUB_DISCORD_ALLOW_FROM . Confirm the bot has message-content intent enabled in Discord Developer Portal. If no response is observed, verify token, allowlists, intents, and runtime logs.","title":"Discord"},{"location":"discord/#discord-integration","text":"Discord allows Bub to run as a remote coding assistant for team channels, threads, and DMs.","title":"Discord Integration"},{"location":"discord/#configure","text":"BUB_DISCORD_ENABLED = true BUB_DISCORD_TOKEN = discord_bot_token BUB_DISCORD_ALLOW_FROM = '[\"123456789012345678\",\"your_discord_name\"]' BUB_DISCORD_ALLOW_CHANNELS = '[\"123456789012345678\"]' Optional: BUB_DISCORD_COMMAND_PREFIX = ! BUB_DISCORD_PROXY = http://127.0.0.1:7890 Notes: If BUB_DISCORD_ALLOW_FROM is empty, all senders are accepted. If BUB_DISCORD_ALLOW_CHANNELS is empty, all channels are accepted. In production, use strict allowlists.","title":"Configure"},{"location":"discord/#run","text":"uv run bub message","title":"Run"},{"location":"discord/#runtime-behavior","text":"Uses discord.py bot runtime. Each Discord channel maps to discord:<channel_id> session key. Inbound text enters the same AgentLoop used by CLI. Outbound immediate output is sent back in-channel (split into chunks when too long). Bub processes messages in these cases: DM channel message includes bub message starts with !bub (or your configured prefix) message mentions the bot message replies to a bot message thread name starts with bub","title":"Runtime Behavior"},{"location":"discord/#security-and-operations","text":"Keep bot token only in .env or a secret manager. Restrict BUB_DISCORD_ALLOW_CHANNELS and BUB_DISCORD_ALLOW_FROM . Confirm the bot has message-content intent enabled in Discord Developer Portal. If no response is observed, verify token, allowlists, intents, and runtime logs.","title":"Security and Operations"},{"location":"features/","text":"Key Features \u00b6 This page summarizes the capabilities users rely on most when working with Bub. 1. Deterministic Command Routing \u00b6 Command mode is explicit: only line-start , triggers command parsing. Known names map to internal commands (for example ,help , ,tools , ,tape.info ). Other comma-prefixed lines run as shell commands (for example ,git status ). Why it matters: fewer accidental tool calls and more predictable behavior. 2. Command Failure Recovery \u00b6 Successful commands return directly. Failed commands are wrapped as structured command blocks and sent back to the model loop. Why it matters: the assistant can debug based on real command output instead of generic guesses. 3. Tape-First Session Memory \u00b6 Bub writes session activity to append-only tape. ,anchors and ,handoff mark phase transitions. ,tape.search and ,tape.info help inspect context quickly. Why it matters: long tasks stay traceable and easier to resume. 4. Unified Tool + Skill View \u00b6 Built-in tools and skills share one registry. Prompt includes compact tool descriptions first. Tool details expand on explicit selection (for example ,tool.describe name=fs.read ). $name hints expand details progressively for both tools and skills. Hints can come from user input or model output (for example $fs.read , $friendly-python ). Why it matters: prompt stays focused while advanced capabilities remain available on demand. 5. Interactive CLI Focused on Real Work \u00b6 Rich interactive shell with history and completions. Ctrl-X toggles shell mode for faster command execution. Same runtime behavior as channel integrations. Why it matters: local debugging and implementation loops are fast and consistent. 6. Message Channel Integration (Telegram + Discord) \u00b6 Optional long-polling Telegram adapter. Optional Discord bot adapter. Per-chat session isolation ( telegram:<chat_id> ). Per-channel session isolation ( discord:<channel_id> ). Optional sender/chat allowlist for access control. Why it matters: you can continue lightweight operations from mobile or remote environments.","title":"Key Features"},{"location":"features/#key-features","text":"This page summarizes the capabilities users rely on most when working with Bub.","title":"Key Features"},{"location":"features/#1-deterministic-command-routing","text":"Command mode is explicit: only line-start , triggers command parsing. Known names map to internal commands (for example ,help , ,tools , ,tape.info ). Other comma-prefixed lines run as shell commands (for example ,git status ). Why it matters: fewer accidental tool calls and more predictable behavior.","title":"1. Deterministic Command Routing"},{"location":"features/#2-command-failure-recovery","text":"Successful commands return directly. Failed commands are wrapped as structured command blocks and sent back to the model loop. Why it matters: the assistant can debug based on real command output instead of generic guesses.","title":"2. Command Failure Recovery"},{"location":"features/#3-tape-first-session-memory","text":"Bub writes session activity to append-only tape. ,anchors and ,handoff mark phase transitions. ,tape.search and ,tape.info help inspect context quickly. Why it matters: long tasks stay traceable and easier to resume.","title":"3. Tape-First Session Memory"},{"location":"features/#4-unified-tool-skill-view","text":"Built-in tools and skills share one registry. Prompt includes compact tool descriptions first. Tool details expand on explicit selection (for example ,tool.describe name=fs.read ). $name hints expand details progressively for both tools and skills. Hints can come from user input or model output (for example $fs.read , $friendly-python ). Why it matters: prompt stays focused while advanced capabilities remain available on demand.","title":"4. Unified Tool + Skill View"},{"location":"features/#5-interactive-cli-focused-on-real-work","text":"Rich interactive shell with history and completions. Ctrl-X toggles shell mode for faster command execution. Same runtime behavior as channel integrations. Why it matters: local debugging and implementation loops are fast and consistent.","title":"5. Interactive CLI Focused on Real Work"},{"location":"features/#6-message-channel-integration-telegram-discord","text":"Optional long-polling Telegram adapter. Optional Discord bot adapter. Per-chat session isolation ( telegram:<chat_id> ). Per-channel session isolation ( discord:<channel_id> ). Optional sender/chat allowlist for access control. Why it matters: you can continue lightweight operations from mobile or remote environments.","title":"6. Message Channel Integration (Telegram + Discord)"},{"location":"telegram/","text":"Telegram Integration \u00b6 Telegram allows Bub to run as a remote coding assistant entry point for lightweight operations. Configure \u00b6 BUB_TELEGRAM_ENABLED = true BUB_TELEGRAM_TOKEN = 123456 :token BUB_TELEGRAM_ALLOW_FROM = '[\"123456789\",\"your_username\"]' BUB_TELEGRAM_ALLOW_CHATS = '[\"123456789\",\"-1001234567890\"]' Notes: If BUB_TELEGRAM_ALLOW_FROM is empty, all senders are accepted. If BUB_TELEGRAM_ALLOW_CHATS is empty, all chats are accepted. If BUB_TELEGRAM_ALLOW_CHATS is not empty, only listed chat_id values are allowed. In production, use a strict allowlist. Run \u00b6 uv run bub message Runtime Behavior \u00b6 Uses long polling. Each Telegram chat maps to telegram:<chat_id> session key. Inbound text enters the same AgentLoop used by CLI. Outbound messages are sent by ChannelManager . Typing indicator is emitted while processing. In group chats, Bub only processes messages that mention/reply to the bot. Security and Operations \u00b6 Keep bot token only in .env or a secret manager. Use a dedicated bot account. Keep allowlist updated with valid user IDs/usernames. If no response is observed, check network, token, allowlists, then runtime/model logs. If uv run bub message exits quickly, verify at least one channel is enabled ( BUB_TELEGRAM_ENABLED=true ).","title":"Telegram"},{"location":"telegram/#telegram-integration","text":"Telegram allows Bub to run as a remote coding assistant entry point for lightweight operations.","title":"Telegram Integration"},{"location":"telegram/#configure","text":"BUB_TELEGRAM_ENABLED = true BUB_TELEGRAM_TOKEN = 123456 :token BUB_TELEGRAM_ALLOW_FROM = '[\"123456789\",\"your_username\"]' BUB_TELEGRAM_ALLOW_CHATS = '[\"123456789\",\"-1001234567890\"]' Notes: If BUB_TELEGRAM_ALLOW_FROM is empty, all senders are accepted. If BUB_TELEGRAM_ALLOW_CHATS is empty, all chats are accepted. If BUB_TELEGRAM_ALLOW_CHATS is not empty, only listed chat_id values are allowed. In production, use a strict allowlist.","title":"Configure"},{"location":"telegram/#run","text":"uv run bub message","title":"Run"},{"location":"telegram/#runtime-behavior","text":"Uses long polling. Each Telegram chat maps to telegram:<chat_id> session key. Inbound text enters the same AgentLoop used by CLI. Outbound messages are sent by ChannelManager . Typing indicator is emitted while processing. In group chats, Bub only processes messages that mention/reply to the bot.","title":"Runtime Behavior"},{"location":"telegram/#security-and-operations","text":"Keep bot token only in .env or a secret manager. Use a dedicated bot account. Keep allowlist updated with valid user IDs/usernames. If no response is observed, check network, token, allowlists, then runtime/model logs. If uv run bub message exits quickly, verify at least one channel is enabled ( BUB_TELEGRAM_ENABLED=true ).","title":"Security and Operations"},{"location":"posts/2025-07-16-baby-bub-bootstrap-milestone/","text":"Baby Bub: From Inspiration to Bootstrap Milestone \u00b6 Genesis: Inspiration from Modern Agents \u00b6 Bub is a CLI-first AI agent, built to \"Bub it. Build it.\" The project draws direct inspiration from How to Build an Agent and Tiny Agents: Building LLM-Powered Agents from Scratch . Both resources distill the essence of tool-using, loop-based, composable, and extensible agents. But Bub is also a response to the new wave of self-improving, self-hosting agents: think Claude Code, SWE-agent, and the broader \"self-bootstrapping\" movement. The goal: an agent that can not only help you build, but can help build (and fix) itself. Architecture: ReAct Loop, Tools, and CLI \u00b6 The ReAct Loop \u00b6 At the heart of Bub is a classic ReAct loop, implemented in src/bub/agent/core.py : class Agent : ... def chat ( self , message : str , on_step : Optional [ Callable [[ str , str ], None ]] = None ) -> str : self . conversation_history . append ( Message ( role = \"user\" , content = message )) while True : ... response = litellm . completion ( ... ) assistant_message = str ( response . choices [ 0 ] . message . content ) self . conversation_history . append ( Message ( role = \"assistant\" , content = assistant_message )) ... tool_calls = self . tool_executor . extract_tool_calls ( assistant_message ) if tool_calls : for tool_call in tool_calls : ... result = self . tool_executor . execute_tool ( tool_name , ** parameters ) observation = f \"Observation: { result . format_result () } \" self . conversation_history . append ( Message ( role = \"user\" , content = observation )) ... continue else : return assistant_message This loop enables the agent to: Parse LLM output for tool calls (ReAct pattern: Thought, Action, Action Input, Observation). Execute tools (file read/write/edit, shell commands) and feed results back into the conversation. Iterate until a \"Final Answer\" is produced. Tool System: Extensible and Safe \u00b6 Tools are registered via a ToolRegistry ( src/bub/agent/tools.py ), and each tool is a Pydantic model with validation and metadata. For example, the RunCommandTool blocks dangerous commands and validates input: class RunCommandTool ( Tool ): ... DANGEROUS_COMMANDS : ClassVar [ set [ str ]] = { \"rm\" , \"del\" , ... } def _validate_command ( self ) -> Optional [ str ]: ... if base_cmd in self . DANGEROUS_COMMANDS : return f \"Dangerous command blocked: { base_cmd } \" This design makes it possible for the agent to safely self-modify, run tests, or even edit its own codebase\u2014crucial for self-improvement. CLI: User Experience and Debuggability \u00b6 The CLI ( src/bub/cli/app.py ) is built with Typer and Rich, providing a modern, user-friendly interface. The renderer ( src/bub/cli/render.py ) supports debug toggling, minimal/verbose TAAO (Thought/Action/Action Input/Observation) output, and clear error reporting. class Renderer : def __init__ ( self ) -> None : self . console : Console = Console () self . _show_debug : bool = False ... Milestone: The First mypy Fix (and Why It Matters) \u00b6 Bub aspires to self-improvement. The first tangible milestone? Fixing the very first mypy error: adding a missing return type annotation to Renderer.__init__ , check out the commit . - def __init__(self): - self.console = Console() - self._show_debug = False + def __init__(self) -> None: + self.console: Console = Console() + self._show_debug: bool = False This change reduced the mypy error count from 24 to 23. Trivial? Maybe. But it's a proof of concept: the agent can reason about, locate, and fix type errors in its own codebase. This is the first step toward a self-hosting, self-healing agent loop\u2014one that can eventually: Run static analysis on itself Propose and apply code fixes Test and validate improvements Looking Forward: Bub as a Bootstrap Agent \u00b6 Bub is still early. But the architecture is in place for: LLM-driven code editing and refactoring Automated type and lint fixes CLI-driven, user-friendly agent workflows The journey from \"fixing a mypy annotation\" to \"full agent self-improvement\" is long, but every bootstrap starts with a single, type-safe step. Project on GitHub Inspired by ampcode.com/how-to-build-an-agent and huggingface.co/blog/tiny-agents See also: Claude Code, SWE-agent, and the broader self-bootstrapping movement","title":"Baby Bub: From Inspiration to Bootstrap Milestone"},{"location":"posts/2025-07-16-baby-bub-bootstrap-milestone/#baby-bub-from-inspiration-to-bootstrap-milestone","text":"","title":"Baby Bub: From Inspiration to Bootstrap Milestone"},{"location":"posts/2025-07-16-baby-bub-bootstrap-milestone/#genesis-inspiration-from-modern-agents","text":"Bub is a CLI-first AI agent, built to \"Bub it. Build it.\" The project draws direct inspiration from How to Build an Agent and Tiny Agents: Building LLM-Powered Agents from Scratch . Both resources distill the essence of tool-using, loop-based, composable, and extensible agents. But Bub is also a response to the new wave of self-improving, self-hosting agents: think Claude Code, SWE-agent, and the broader \"self-bootstrapping\" movement. The goal: an agent that can not only help you build, but can help build (and fix) itself.","title":"Genesis: Inspiration from Modern Agents"},{"location":"posts/2025-07-16-baby-bub-bootstrap-milestone/#architecture-react-loop-tools-and-cli","text":"","title":"Architecture: ReAct Loop, Tools, and CLI"},{"location":"posts/2025-07-16-baby-bub-bootstrap-milestone/#the-react-loop","text":"At the heart of Bub is a classic ReAct loop, implemented in src/bub/agent/core.py : class Agent : ... def chat ( self , message : str , on_step : Optional [ Callable [[ str , str ], None ]] = None ) -> str : self . conversation_history . append ( Message ( role = \"user\" , content = message )) while True : ... response = litellm . completion ( ... ) assistant_message = str ( response . choices [ 0 ] . message . content ) self . conversation_history . append ( Message ( role = \"assistant\" , content = assistant_message )) ... tool_calls = self . tool_executor . extract_tool_calls ( assistant_message ) if tool_calls : for tool_call in tool_calls : ... result = self . tool_executor . execute_tool ( tool_name , ** parameters ) observation = f \"Observation: { result . format_result () } \" self . conversation_history . append ( Message ( role = \"user\" , content = observation )) ... continue else : return assistant_message This loop enables the agent to: Parse LLM output for tool calls (ReAct pattern: Thought, Action, Action Input, Observation). Execute tools (file read/write/edit, shell commands) and feed results back into the conversation. Iterate until a \"Final Answer\" is produced.","title":"The ReAct Loop"},{"location":"posts/2025-07-16-baby-bub-bootstrap-milestone/#tool-system-extensible-and-safe","text":"Tools are registered via a ToolRegistry ( src/bub/agent/tools.py ), and each tool is a Pydantic model with validation and metadata. For example, the RunCommandTool blocks dangerous commands and validates input: class RunCommandTool ( Tool ): ... DANGEROUS_COMMANDS : ClassVar [ set [ str ]] = { \"rm\" , \"del\" , ... } def _validate_command ( self ) -> Optional [ str ]: ... if base_cmd in self . DANGEROUS_COMMANDS : return f \"Dangerous command blocked: { base_cmd } \" This design makes it possible for the agent to safely self-modify, run tests, or even edit its own codebase\u2014crucial for self-improvement.","title":"Tool System: Extensible and Safe"},{"location":"posts/2025-07-16-baby-bub-bootstrap-milestone/#cli-user-experience-and-debuggability","text":"The CLI ( src/bub/cli/app.py ) is built with Typer and Rich, providing a modern, user-friendly interface. The renderer ( src/bub/cli/render.py ) supports debug toggling, minimal/verbose TAAO (Thought/Action/Action Input/Observation) output, and clear error reporting. class Renderer : def __init__ ( self ) -> None : self . console : Console = Console () self . _show_debug : bool = False ...","title":"CLI: User Experience and Debuggability"},{"location":"posts/2025-07-16-baby-bub-bootstrap-milestone/#milestone-the-first-mypy-fix-and-why-it-matters","text":"Bub aspires to self-improvement. The first tangible milestone? Fixing the very first mypy error: adding a missing return type annotation to Renderer.__init__ , check out the commit . - def __init__(self): - self.console = Console() - self._show_debug = False + def __init__(self) -> None: + self.console: Console = Console() + self._show_debug: bool = False This change reduced the mypy error count from 24 to 23. Trivial? Maybe. But it's a proof of concept: the agent can reason about, locate, and fix type errors in its own codebase. This is the first step toward a self-hosting, self-healing agent loop\u2014one that can eventually: Run static analysis on itself Propose and apply code fixes Test and validate improvements","title":"Milestone: The First mypy Fix (and Why It Matters)"},{"location":"posts/2025-07-16-baby-bub-bootstrap-milestone/#looking-forward-bub-as-a-bootstrap-agent","text":"Bub is still early. But the architecture is in place for: LLM-driven code editing and refactoring Automated type and lint fixes CLI-driven, user-friendly agent workflows The journey from \"fixing a mypy annotation\" to \"full agent self-improvement\" is long, but every bootstrap starts with a single, type-safe step. Project on GitHub Inspired by ampcode.com/how-to-build-an-agent and huggingface.co/blog/tiny-agents See also: Claude Code, SWE-agent, and the broader self-bootstrapping movement","title":"Looking Forward: Bub as a Bootstrap Agent"}]}