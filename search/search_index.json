{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Bub Docs \u00b6 What Bub Is \u00b6 Bub is a tape-first coding agent runtime: - deterministic, forward-only session flow, - explicit anchors and handoff for phase transitions, - shared command router for user and assistant outputs. Core Rules \u00b6 Internal commands use , prefix. Shell commands run through bash tool. Command success returns directly; command failure falls back to model. $ is hint-only for potential tool/skill usage. Tape is append-only; no runtime fork/rollback semantics. Read Next \u00b6 Architecture Interactive CLI Telegram Integration Rewrite Plan (tracking)","title":"Home"},{"location":"#bub-docs","text":"","title":"Bub Docs"},{"location":"#what-bub-is","text":"Bub is a tape-first coding agent runtime: - deterministic, forward-only session flow, - explicit anchors and handoff for phase transitions, - shared command router for user and assistant outputs.","title":"What Bub Is"},{"location":"#core-rules","text":"Internal commands use , prefix. Shell commands run through bash tool. Command success returns directly; command failure falls back to model. $ is hint-only for potential tool/skill usage. Tape is append-only; no runtime fork/rollback semantics.","title":"Core Rules"},{"location":"#read-next","text":"Architecture Interactive CLI Telegram Integration Rewrite Plan (tracking)","title":"Read Next"},{"location":"architecture/","text":"Architecture \u00b6 Design Goal \u00b6 Bub uses one endless tape per session and keeps behavior inspectable: - facts are appended, never rewritten, - runtime state is rebuilt from anchors, - handoff marks phase transitions with minimal structured state. Runtime Topology \u00b6 input -> InputRouter -> AgentLoop -> ModelRunner -> InputRouter(assistant output) -> ... \\-> direct command response Main modules: bub.app.runtime : workspace runtime + per-session runtime creation. bub.core.router : command detection/execution for user and assistant outputs. bub.core.agent_loop : turn orchestration. bub.core.model_runner : bounded model loop and follow-up command context. bub.tape.* : persistent tape store and handoff/anchor helpers. Tape and Anchors \u00b6 Tape store: - file-backed JSONL per workspace + session tape name. - append-only TapeEntry . Anchor usage: - bootstrap anchor is created once ( session/start ). - ,handoff writes anchor with optional summary and next_steps . - context selection is LAST_ANCHOR by default. Tool and Skill Unification \u00b6 All capabilities are exposed via one registry: - builtin tools ( bash , fs.* , web.* , tape.* , control commands), - skill tools: - skills.list - skills.describe - dynamic skill.<skill_name> . Progressive exposure: - system prompt includes compact tool list, - detailed schema is expanded after selection ( tool.describe / invocation). Agent Loop Contract \u00b6 Per user turn: 1. Route user input. 2. If command success: return. 3. If command failure or NL input: enter model loop. 4. Parse assistant output with same router. 5. If assistant emitted commands: execute and feed command blocks into next model step. 6. Stop on plain final text, explicit quit, or max_steps . Channel Integration \u00b6 blinker signal bus: - inbound signal -> runtime handle_input, - outbound signal -> channel adapter send. Current external adapter: - Telegram long polling ( python-telegram-bot ).","title":"Architecture"},{"location":"architecture/#architecture","text":"","title":"Architecture"},{"location":"architecture/#design-goal","text":"Bub uses one endless tape per session and keeps behavior inspectable: - facts are appended, never rewritten, - runtime state is rebuilt from anchors, - handoff marks phase transitions with minimal structured state.","title":"Design Goal"},{"location":"architecture/#runtime-topology","text":"input -> InputRouter -> AgentLoop -> ModelRunner -> InputRouter(assistant output) -> ... \\-> direct command response Main modules: bub.app.runtime : workspace runtime + per-session runtime creation. bub.core.router : command detection/execution for user and assistant outputs. bub.core.agent_loop : turn orchestration. bub.core.model_runner : bounded model loop and follow-up command context. bub.tape.* : persistent tape store and handoff/anchor helpers.","title":"Runtime Topology"},{"location":"architecture/#tape-and-anchors","text":"Tape store: - file-backed JSONL per workspace + session tape name. - append-only TapeEntry . Anchor usage: - bootstrap anchor is created once ( session/start ). - ,handoff writes anchor with optional summary and next_steps . - context selection is LAST_ANCHOR by default.","title":"Tape and Anchors"},{"location":"architecture/#tool-and-skill-unification","text":"All capabilities are exposed via one registry: - builtin tools ( bash , fs.* , web.* , tape.* , control commands), - skill tools: - skills.list - skills.describe - dynamic skill.<skill_name> . Progressive exposure: - system prompt includes compact tool list, - detailed schema is expanded after selection ( tool.describe / invocation).","title":"Tool and Skill Unification"},{"location":"architecture/#agent-loop-contract","text":"Per user turn: 1. Route user input. 2. If command success: return. 3. If command failure or NL input: enter model loop. 4. Parse assistant output with same router. 5. If assistant emitted commands: execute and feed command blocks into next model step. 6. Stop on plain final text, explicit quit, or max_steps .","title":"Agent Loop Contract"},{"location":"architecture/#channel-integration","text":"blinker signal bus: - inbound signal -> runtime handle_input, - outbound signal -> channel adapter send. Current external adapter: - Telegram long polling ( python-telegram-bot ).","title":"Channel Integration"},{"location":"cli/","text":"Interactive CLI \u00b6 Start \u00b6 uv run bub chat Optional: uv run bub chat --workspace /path/to/repo --model openrouter:openrouter/auto --max-tokens 1400 Interaction Model \u00b6 Single interactive mode only. PromptToolkit input with history and bottom status bar. Shared runtime contract with channel adapters. Command Examples \u00b6 ,help ,tools ,tool.describe name=fs.read ,skills.list ,handoff name=phase-x summary=\"done\" ,tape.info ,quit Shell command examples: git status uv run pytest -q Status Bar \u00b6 Bottom toolbar displays: - current time, - mode, - model id, - tape summary ( entries , anchors , last_anchor ). Exit \u00b6 ,quit Ctrl-D","title":"Interactive CLI"},{"location":"cli/#interactive-cli","text":"","title":"Interactive CLI"},{"location":"cli/#start","text":"uv run bub chat Optional: uv run bub chat --workspace /path/to/repo --model openrouter:openrouter/auto --max-tokens 1400","title":"Start"},{"location":"cli/#interaction-model","text":"Single interactive mode only. PromptToolkit input with history and bottom status bar. Shared runtime contract with channel adapters.","title":"Interaction Model"},{"location":"cli/#command-examples","text":",help ,tools ,tool.describe name=fs.read ,skills.list ,handoff name=phase-x summary=\"done\" ,tape.info ,quit Shell command examples: git status uv run pytest -q","title":"Command Examples"},{"location":"cli/#status-bar","text":"Bottom toolbar displays: - current time, - mode, - model id, - tape summary ( entries , anchors , last_anchor ).","title":"Status Bar"},{"location":"cli/#exit","text":",quit Ctrl-D","title":"Exit"},{"location":"telegram/","text":"Telegram Integration \u00b6 Configure \u00b6 BUB_TELEGRAM_ENABLED = true BUB_TELEGRAM_TOKEN = 123456 :token BUB_TELEGRAM_ALLOW_FROM =[ \"123456789\" , \"your_username\" ] Run \u00b6 uv run bub telegram Behavior \u00b6 Uses long polling. Each chat maps to deterministic session key: telegram:<chat_id> . Inbound text goes through the same AgentLoop as CLI. Outbound messages are dispatched through ChannelManager . Typing indicator runs while message is being processed. Security \u00b6 If allowlist is set, only listed user IDs/usernames can use the bot. If allowlist is empty, all senders are accepted.","title":"Telegram"},{"location":"telegram/#telegram-integration","text":"","title":"Telegram Integration"},{"location":"telegram/#configure","text":"BUB_TELEGRAM_ENABLED = true BUB_TELEGRAM_TOKEN = 123456 :token BUB_TELEGRAM_ALLOW_FROM =[ \"123456789\" , \"your_username\" ]","title":"Configure"},{"location":"telegram/#run","text":"uv run bub telegram","title":"Run"},{"location":"telegram/#behavior","text":"Uses long polling. Each chat maps to deterministic session key: telegram:<chat_id> . Inbound text goes through the same AgentLoop as CLI. Outbound messages are dispatched through ChannelManager . Typing indicator runs while message is being processed.","title":"Behavior"},{"location":"telegram/#security","text":"If allowlist is set, only listed user IDs/usernames can use the bot. If allowlist is empty, all senders are accepted.","title":"Security"},{"location":"posts/2025-07-16-baby-bub-bootstrap-milestone/","text":"Baby Bub: From Inspiration to Bootstrap Milestone \u00b6 Genesis: Inspiration from Modern Agents \u00b6 Bub is a CLI-first AI agent, built to \"Bub it. Build it.\" The project draws direct inspiration from How to Build an Agent and Tiny Agents: Building LLM-Powered Agents from Scratch . Both resources distill the essence of tool-using, loop-based, composable, and extensible agents. But Bub is also a response to the new wave of self-improving, self-hosting agents: think Claude Code, SWE-agent, and the broader \"self-bootstrapping\" movement. The goal: an agent that can not only help you build, but can help build (and fix) itself. Architecture: ReAct Loop, Tools, and CLI \u00b6 The ReAct Loop \u00b6 At the heart of Bub is a classic ReAct loop, implemented in src/bub/agent/core.py : class Agent : ... def chat ( self , message : str , on_step : Optional [ Callable [[ str , str ], None ]] = None ) -> str : self . conversation_history . append ( Message ( role = \"user\" , content = message )) while True : ... response = litellm . completion ( ... ) assistant_message = str ( response . choices [ 0 ] . message . content ) self . conversation_history . append ( Message ( role = \"assistant\" , content = assistant_message )) ... tool_calls = self . tool_executor . extract_tool_calls ( assistant_message ) if tool_calls : for tool_call in tool_calls : ... result = self . tool_executor . execute_tool ( tool_name , ** parameters ) observation = f \"Observation: { result . format_result () } \" self . conversation_history . append ( Message ( role = \"user\" , content = observation )) ... continue else : return assistant_message This loop enables the agent to: Parse LLM output for tool calls (ReAct pattern: Thought, Action, Action Input, Observation). Execute tools (file read/write/edit, shell commands) and feed results back into the conversation. Iterate until a \"Final Answer\" is produced. Tool System: Extensible and Safe \u00b6 Tools are registered via a ToolRegistry ( src/bub/agent/tools.py ), and each tool is a Pydantic model with validation and metadata. For example, the RunCommandTool blocks dangerous commands and validates input: class RunCommandTool ( Tool ): ... DANGEROUS_COMMANDS : ClassVar [ set [ str ]] = { \"rm\" , \"del\" , ... } def _validate_command ( self ) -> Optional [ str ]: ... if base_cmd in self . DANGEROUS_COMMANDS : return f \"Dangerous command blocked: { base_cmd } \" This design makes it possible for the agent to safely self-modify, run tests, or even edit its own codebase\u2014crucial for self-improvement. CLI: User Experience and Debuggability \u00b6 The CLI ( src/bub/cli/app.py ) is built with Typer and Rich, providing a modern, user-friendly interface. The renderer ( src/bub/cli/render.py ) supports debug toggling, minimal/verbose TAAO (Thought/Action/Action Input/Observation) output, and clear error reporting. class Renderer : def __init__ ( self ) -> None : self . console : Console = Console () self . _show_debug : bool = False ... Milestone: The First mypy Fix (and Why It Matters) \u00b6 Bub aspires to self-improvement. The first tangible milestone? Fixing the very first mypy error: adding a missing return type annotation to Renderer.__init__ , check out the commit . - def __init__(self): - self.console = Console() - self._show_debug = False + def __init__(self) -> None: + self.console: Console = Console() + self._show_debug: bool = False This change reduced the mypy error count from 24 to 23. Trivial? Maybe. But it's a proof of concept: the agent can reason about, locate, and fix type errors in its own codebase. This is the first step toward a self-hosting, self-healing agent loop\u2014one that can eventually: Run static analysis on itself Propose and apply code fixes Test and validate improvements Looking Forward: Bub as a Bootstrap Agent \u00b6 Bub is still early. But the architecture is in place for: LLM-driven code editing and refactoring Automated type and lint fixes CLI-driven, user-friendly agent workflows The journey from \"fixing a mypy annotation\" to \"full agent self-improvement\" is long, but every bootstrap starts with a single, type-safe step. Project on GitHub Inspired by ampcode.com/how-to-build-an-agent and huggingface.co/blog/tiny-agents See also: Claude Code, SWE-agent, and the broader self-bootstrapping movement","title":"Baby Bub: From Inspiration to Bootstrap Milestone"},{"location":"posts/2025-07-16-baby-bub-bootstrap-milestone/#baby-bub-from-inspiration-to-bootstrap-milestone","text":"","title":"Baby Bub: From Inspiration to Bootstrap Milestone"},{"location":"posts/2025-07-16-baby-bub-bootstrap-milestone/#genesis-inspiration-from-modern-agents","text":"Bub is a CLI-first AI agent, built to \"Bub it. Build it.\" The project draws direct inspiration from How to Build an Agent and Tiny Agents: Building LLM-Powered Agents from Scratch . Both resources distill the essence of tool-using, loop-based, composable, and extensible agents. But Bub is also a response to the new wave of self-improving, self-hosting agents: think Claude Code, SWE-agent, and the broader \"self-bootstrapping\" movement. The goal: an agent that can not only help you build, but can help build (and fix) itself.","title":"Genesis: Inspiration from Modern Agents"},{"location":"posts/2025-07-16-baby-bub-bootstrap-milestone/#architecture-react-loop-tools-and-cli","text":"","title":"Architecture: ReAct Loop, Tools, and CLI"},{"location":"posts/2025-07-16-baby-bub-bootstrap-milestone/#the-react-loop","text":"At the heart of Bub is a classic ReAct loop, implemented in src/bub/agent/core.py : class Agent : ... def chat ( self , message : str , on_step : Optional [ Callable [[ str , str ], None ]] = None ) -> str : self . conversation_history . append ( Message ( role = \"user\" , content = message )) while True : ... response = litellm . completion ( ... ) assistant_message = str ( response . choices [ 0 ] . message . content ) self . conversation_history . append ( Message ( role = \"assistant\" , content = assistant_message )) ... tool_calls = self . tool_executor . extract_tool_calls ( assistant_message ) if tool_calls : for tool_call in tool_calls : ... result = self . tool_executor . execute_tool ( tool_name , ** parameters ) observation = f \"Observation: { result . format_result () } \" self . conversation_history . append ( Message ( role = \"user\" , content = observation )) ... continue else : return assistant_message This loop enables the agent to: Parse LLM output for tool calls (ReAct pattern: Thought, Action, Action Input, Observation). Execute tools (file read/write/edit, shell commands) and feed results back into the conversation. Iterate until a \"Final Answer\" is produced.","title":"The ReAct Loop"},{"location":"posts/2025-07-16-baby-bub-bootstrap-milestone/#tool-system-extensible-and-safe","text":"Tools are registered via a ToolRegistry ( src/bub/agent/tools.py ), and each tool is a Pydantic model with validation and metadata. For example, the RunCommandTool blocks dangerous commands and validates input: class RunCommandTool ( Tool ): ... DANGEROUS_COMMANDS : ClassVar [ set [ str ]] = { \"rm\" , \"del\" , ... } def _validate_command ( self ) -> Optional [ str ]: ... if base_cmd in self . DANGEROUS_COMMANDS : return f \"Dangerous command blocked: { base_cmd } \" This design makes it possible for the agent to safely self-modify, run tests, or even edit its own codebase\u2014crucial for self-improvement.","title":"Tool System: Extensible and Safe"},{"location":"posts/2025-07-16-baby-bub-bootstrap-milestone/#cli-user-experience-and-debuggability","text":"The CLI ( src/bub/cli/app.py ) is built with Typer and Rich, providing a modern, user-friendly interface. The renderer ( src/bub/cli/render.py ) supports debug toggling, minimal/verbose TAAO (Thought/Action/Action Input/Observation) output, and clear error reporting. class Renderer : def __init__ ( self ) -> None : self . console : Console = Console () self . _show_debug : bool = False ...","title":"CLI: User Experience and Debuggability"},{"location":"posts/2025-07-16-baby-bub-bootstrap-milestone/#milestone-the-first-mypy-fix-and-why-it-matters","text":"Bub aspires to self-improvement. The first tangible milestone? Fixing the very first mypy error: adding a missing return type annotation to Renderer.__init__ , check out the commit . - def __init__(self): - self.console = Console() - self._show_debug = False + def __init__(self) -> None: + self.console: Console = Console() + self._show_debug: bool = False This change reduced the mypy error count from 24 to 23. Trivial? Maybe. But it's a proof of concept: the agent can reason about, locate, and fix type errors in its own codebase. This is the first step toward a self-hosting, self-healing agent loop\u2014one that can eventually: Run static analysis on itself Propose and apply code fixes Test and validate improvements","title":"Milestone: The First mypy Fix (and Why It Matters)"},{"location":"posts/2025-07-16-baby-bub-bootstrap-milestone/#looking-forward-bub-as-a-bootstrap-agent","text":"Bub is still early. But the architecture is in place for: LLM-driven code editing and refactoring Automated type and lint fixes CLI-driven, user-friendly agent workflows The journey from \"fixing a mypy annotation\" to \"full agent self-improvement\" is long, but every bootstrap starts with a single, type-safe step. Project on GitHub Inspired by ampcode.com/how-to-build-an-agent and huggingface.co/blog/tiny-agents See also: Claude Code, SWE-agent, and the broader self-bootstrapping movement","title":"Looking Forward: Bub as a Bootstrap Agent"}]}